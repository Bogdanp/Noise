#lang racket/base

(require racket/format
         racket/match
         racket/string
         "private/backend.rkt"
         "private/serde.rkt")

(provide
 write-Swift-code)

(define (swift-type t)
  ((field-type-swift-proc t)))

(define (~hex n)
  (~a "0x" (~a #:min-width 4 #:left-pad-string "0" #:align 'right (number->string n 16))))

(define (~camel-case id)
  (regexp-replace* #rx"-([a-z])"
                   (symbol->string id)
                   (lambda (_ start)
                     (string-upcase start))))

(define (write-Swift-code [out (current-output-port)])
  (fprintf out "// This file was automatically generated by noise-serde-lib.~n")
  (fprintf out "import Foundation~n")
  (fprintf out "import NoiseBackend~n")
  (fprintf out "import NoiseSerde~n")

  (for ([id (in-list (sort (hash-keys enum-infos) <) )])
    (define e (hash-ref enum-infos id))
    (fprintf out "~n")
    (write-enum-code e out))

  (for ([id (in-list (sort (hash-keys record-infos) <))])
    (define r (hash-ref record-infos id))
    (fprintf out "~n")
    (write-record-code r out))

  (fprintf out "~n")
  (fprintf out "public class Backend {~n")
  (fprintf out "  let impl: NoiseBackend.Backend!~n~n")
  (fprintf out "  init(withZo zo: URL, andMod mod: String, andProc proc: String) {~n")
  (fprintf out "    impl = NoiseBackend.Backend(withZo: zo, andMod: mod, andProc: proc)~n")
  (fprintf out "  }~n")
  (define sorted-rpc-ids (sort (hash-keys rpc-infos) <))
  (for ([id (in-list sorted-rpc-ids)])
    (match-define (rpc-info _ name args type _proc)
      (hash-ref rpc-infos id))
    (define args-str
      (string-join
       (for/list ([arg (in-list args)])
         (match-define (rpc-arg label name type) arg)
         (format "~a ~a: ~a"
                 (~camel-case label)
                 (~camel-case name)
                 (swift-type type)))
       ", "))
    (fprintf out "~n")
    (fprintf out "  public func ~a(~a) -> Future<String, ~a> {~n" (~camel-case name) args-str (swift-type type))
    (fprintf out "    return impl.send(~n")
    (fprintf out "      writeProc: { (out: OutputPort) in~n")
    (fprintf out "        UVarint(~a).write(to: out)~n" (~hex id))
    (for ([arg (in-list args)])
      (match-define (rpc-arg _label name _type) arg)
      (fprintf out "        ~a.write(to: out)~n" (~camel-case name)))
    (fprintf out "      },~n")
    (fprintf out "      readProc: { (inp: InputPort, buf: inout Data) -> ~a in~n" (swift-type type))
    (fprintf out "        return ~a.read(from: inp, using: &buf)~n" (swift-type type))
    (fprintf out "      }~n")
    (fprintf out "    )~n")
    (fprintf out "  }~n"))
  (fprintf out "}~n"))

(define (write-enum-code e [out (current-output-port)])
  (match-define (enum-info _id name variants) e)
  (fprintf out "public enum ~a: Readable, Writable {~n" name)
  (for ([v (in-vector variants)])
    (match-define (enum-variant _id name _constructor fields) v)
    (cond
      [(null? fields)
       (fprintf out "  case ~a~n" (~camel-case name))]
      [else
       (define fields-str
         (string-join
          (for/list ([f (in-list fields)])
            (swift-type (enum-variant-field-type f)))
          ", "))
       (fprintf out "  case ~a(~a)~n" (~camel-case name) fields-str)]))

  (fprintf out "~n")
  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a {~n" name)
  (fprintf out "    let tag = UVarint.read(from: inp, using: &buf)~n")
  (fprintf out "    switch tag {~n")
  (for ([v (in-vector variants)])
    (match-define (enum-variant id name _constructor fields) v)
    (fprintf out "    case ~a:~n" (~hex id))
    (cond
      [(null? fields)
       (fprintf out "      return .~a~n" (~camel-case name))]
      [else
       (fprintf out "      return .~a(~n" (~camel-case name))
       (define len (length fields))
       (for ([(f idx) (in-indexed (in-list fields))])
         (define last? (= idx (sub1 len)))
         (define maybe-comma (if last? "" ","))
         (define type (swift-type (enum-variant-field-type f)))
         (fprintf out "        ~a.read(from: inp, using: &buf)~a~n" type maybe-comma))
       (fprintf out "      )~n")]))
  (fprintf out "    default:~n")
  (fprintf out "      preconditionFailure(\"~a: unexpected tag \\(tag)\")~n" name)
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    switch self {~n")
  (for ([v (in-vector variants)])
    (match-define (enum-variant id name _constructor fields) v)
    (define field-names
      (map (compose1 ~camel-case enum-variant-field-name) fields))
    (define binders-str
      (if (null? field-names)
          ""
          (format "(~a)" (string-join
                          (for/list ([name (in-list field-names)])
                            (format "let ~a" name))
                          ", "))))
    (fprintf out "    case .~a~a:~n" (~camel-case name) binders-str)
    (fprintf out "      UVarint(~a).write(to: out)~n" (~hex id))
    (for ([name (in-list field-names)])
      (fprintf out "      ~a.write(to: out)~n" name)))
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(define (write-record-code r [out (current-output-port)])
  (match-define (record-info _id name _constructor fields) r)
  (fprintf out "public struct ~a: Readable, Writable {~n" name)
  (for ([f (in-list fields)])
    (fprintf out
             "  public let ~a: ~a~n"
             (~camel-case (record-field-id f))
             (swift-type (record-field-type f))))

  (fprintf out "~n")
  (fprintf out "  public init(~n")
  (define len (length fields))
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "    ~a: ~a~a~n" (~camel-case id) type maybe-comma))
  (fprintf out "  ) {~n")
  (for ([f (in-list fields)])
    (define id (record-field-id f))
    (define camel-id (~camel-case id))
    (fprintf out "    self.~a = ~a~n" camel-id camel-id))
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a {~n" name)
  (fprintf out "    return ~a(~n" name)
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define camel-id (~camel-case id))
    (define type (swift-type (record-field-type f)))
    (fprintf out "      ~a: ~a.read(from: inp, using: &buf)~a~n" camel-id type maybe-comma))
  (fprintf out "    )~n")
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public func write(to out: OutputPort) {~n")
  (for ([f (in-list fields)])
    (define camel-id (~camel-case (record-field-id f)))
    (fprintf out "    ~a.write(to: out)~n" camel-id))
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(module+ main
  (require racket/cmdline)
  (command-line
   #:args [modpath]
   (parameterize ([current-output-port (current-error-port)])
     (dynamic-require modpath #f)))
  (write-Swift-code))
