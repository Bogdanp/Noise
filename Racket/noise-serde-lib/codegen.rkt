#lang racket/base

(require racket/format
         racket/match
         racket/string
         threading
         "private/backend.rkt"
         "private/callout.rkt"
         "private/serde.rkt")

(provide
 write-Swift-code)

(define (swift-type t)
  ((field-type-swift-proc t)))

(define (~hex n)
  (~a "0x" (~a #:min-width 4 #:left-pad-string "0" #:align 'right (number->string n 16))))

(define (~name id)
  (~> (symbol->string id)
      (regexp-replace* #rx"\\?" _ "Huh")
      (regexp-replace* #rx"-([a-z])" _ (Î» (_ start) (string-upcase start)))))

(define (write-Swift-code [out (current-output-port)])
  (fprintf out "// This file was automatically generated by noise-serde-lib.~n")
  (fprintf out "import Foundation~n")
  (fprintf out "import NoiseBackend~n")
  (fprintf out "import NoiseSerde~n")

  (for ([id (in-list (sort (hash-keys enum-infos) <) )])
    (define e (hash-ref enum-infos id))
    (fprintf out "~n")
    (write-enum-code e out))

  (for ([id (in-list (sort (hash-keys record-infos) <))])
    (define r (hash-ref record-infos id))
    (fprintf out "~n")
    (write-record-code r out))

  (fprintf out "~n")
  (fprintf out "public final class Backend: Sendable {~n")
  (fprintf out "  let impl: NoiseBackend.Backend!~n~n")
  (fprintf out "  init(withZo zo: URL, andMod mod: String, andProc proc: String) {~n")
  (fprintf out "    impl = NoiseBackend.Backend(withZo: zo, andMod: mod, andProc: proc)~n")
  (fprintf out "  }~n")

  (define sorted-rpc-ids (sort (hash-keys rpc-infos) <))
  (for ([id (in-list sorted-rpc-ids)])
    (match-define (rpc-info _ name args type _proc)
      (hash-ref rpc-infos id))
    (define args-str
      (string-join
       (for/list ([arg (in-list args)])
         (match-define (rpc-arg label name type) arg)
         (define formatted-label (~name label))
         (define formatted-name (~name name))
         (define formatted-type (swift-type type))
         (if (equal? formatted-label formatted-name)
             (format "~a: ~a" formatted-label formatted-type)
             (format "~a ~a: ~a" formatted-label formatted-name formatted-type)))
       ", "))
    (define arg-pairs-str
      (string-join
       (for/list ([arg (in-list args)])
         (match-define (rpc-arg label name _type) arg)
         (if (eq? label '_)
             (~name name)
             (format "~a: ~a"
                     (~name label)
                     (~name name))))
       ", "))
    (fprintf out "~n")
    (fprintf out "  public func ~a(~a) -> Future<String, ~a> {~n" (~name name) args-str (swift-type type))
    (fprintf out "    return impl.send(~n")
    (fprintf out "      writeProc: { (out: OutputPort) in~n")
    (fprintf out "        UVarint(~a).write(to: out)~n" (~hex id))
    (for ([arg (in-list args)])
      (match-define (rpc-arg _label name _type) arg)
      (fprintf out "        ~a.write(to: out)~n" (~name name)))
    (fprintf out "      },~n")
    (cond
      [(eq? type Void)
       (fprintf out "      readProc: { (inp: InputPort, buf: inout Data) -> Void in }~n")]
      [else
       (fprintf out "      readProc: { (inp: InputPort, buf: inout Data) -> ~a in~n" (swift-type type))
       (fprintf out "        return ~a.read(from: inp, using: &buf)~n" (swift-type type))
       (fprintf out "      }~n")])
    (fprintf out "    )~n")
    (fprintf out "  }~n")
    (fprintf out "~n")
    (fprintf out "  public func ~a(~a) async throws -> ~a {~n" (~name name) args-str (swift-type type))
    (fprintf out "    return try await FutureUtil.asyncify(~a(~a))~n" (~name name) arg-pairs-str)
    (fprintf out "  }~n"))

  (define sorted-callout-ids (sort (hash-keys callout-infos) <))
  (for ([id (in-list sorted-callout-ids)])
    (match-define (callout-info _ name args _cbox)
      (hash-ref callout-infos id))
    (define proc-name (~name name))
    (define proc-type
      (format "@escaping @Sendable (~a) -> Void"
              (string-join
               (map (compose1 swift-type callout-arg-type) args)
               ", ")))
    (fprintf out "~n")
    (fprintf out "  public func installCallback(~a proc: ~a) -> Future<String, Void> {~n" proc-name proc-type)
    (fprintf out "    return NoiseBackend.installCallback(id: ~a, rpc: self.installCallback(internalWithId:andAddr:)) { inp in~n" id)
    (fprintf out "      var buf = Data(count: 8*1024)~n")
    (fprintf out "      proc(~n")
    (define last-idx (sub1 (length args)))
    (for ([(arg idx) (in-indexed (in-list args))])
      (match-define (callout-arg _name type) arg)
      (define maybe-comma (if (= idx last-idx) "" ","))
      (fprintf out "        ~a.read(from: inp, using: &buf)~a~n" (swift-type type) maybe-comma))
    (fprintf out "      )~n")
    (fprintf out "    }~n")
    (fprintf out "  }~n"))

  (fprintf out "}~n"))

(define (write-enum-code e [out (current-output-port)])
  (match-define (enum-info _id name protocols variants) e)
  (define ~protocols
    (let ([protocols (append protocols '(Readable Sendable Writable))])
      (string-join (map symbol->string protocols) ", ")))
  (fprintf out "public enum ~a: ~a {~n" name ~protocols)
  (for ([v (in-vector variants)])
    (match-define (enum-variant _id name _constructor fields) v)
    (cond
      [(null? fields)
       (fprintf out "  case ~a~n" (~name name))]
      [else
       (define fields-str
         (string-join
          (for/list ([f (in-list fields)])
            (swift-type (enum-variant-field-type f)))
          ", "))
       (fprintf out "  case ~a(~a)~n" (~name name) fields-str)]))

  (fprintf out "~n")
  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a {~n" name)
  (fprintf out "    let tag = UVarint.read(from: inp, using: &buf)~n")
  (fprintf out "    switch tag {~n")
  (for ([v (in-vector variants)])
    (match-define (enum-variant id name _constructor fields) v)
    (fprintf out "    case ~a:~n" (~hex id))
    (cond
      [(null? fields)
       (fprintf out "      return .~a~n" (~name name))]
      [else
       (fprintf out "      return .~a(~n" (~name name))
       (define len (length fields))
       (for ([(f idx) (in-indexed (in-list fields))])
         (define last? (= idx (sub1 len)))
         (define maybe-comma (if last? "" ","))
         (define type (swift-type (enum-variant-field-type f)))
         (fprintf out "        ~a.read(from: inp, using: &buf)~a~n" type maybe-comma))
       (fprintf out "      )~n")]))
  (fprintf out "    default:~n")
  (fprintf out "      preconditionFailure(\"~a: unexpected tag \\(tag)\")~n" name)
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    switch self {~n")
  (for ([v (in-vector variants)])
    (match-define (enum-variant id name _constructor fields) v)
    (define field-names
      (map (compose1 ~name enum-variant-field-name) fields))
    (define binders-str
      (if (null? field-names)
          ""
          (format "(~a)" (string-join
                          (for/list ([name (in-list field-names)])
                            (format "let ~a" name))
                          ", "))))
    (fprintf out "    case .~a~a:~n" (~name name) binders-str)
    (fprintf out "      UVarint(~a).write(to: out)~n" (~hex id))
    (for ([name (in-list field-names)])
      (fprintf out "      ~a.write(to: out)~n" name)))
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(define (write-record-code r [out (current-output-port)])
  (match-define (record-info _id name _constructor protocols fields) r)
  (define ~protocols
    (let ([protocols (append protocols '(Readable Sendable Writable))])
      (string-join (map symbol->string protocols) ", ")))
  (fprintf out "public struct ~a: ~a {~n" name ~protocols)
  (for ([f (in-list fields)])
    (fprintf out
             "  public ~a ~a: ~a~n"
             (if (record-field-mutable? f) "var" "let")
             (~name (record-field-id f))
             (swift-type (record-field-type f))))

  (fprintf out "~n")
  (fprintf out "  public init(~n")
  (define len (length fields))
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "    ~a: ~a~a~n" (~name id) type maybe-comma))
  (fprintf out "  ) {~n")
  (for ([f (in-list fields)])
    (define id (record-field-id f))
    (define camel-id (~name id))
    (fprintf out "    self.~a = ~a~n" camel-id camel-id))
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a {~n" name)
  (fprintf out "    return ~a(~n" name)
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define camel-id (~name id))
    (define type (swift-type (record-field-type f)))
    (fprintf out "      ~a: ~a.read(from: inp, using: &buf)~a~n" camel-id type maybe-comma))
  (fprintf out "    )~n")
  (fprintf out "  }~n")

  (fprintf out "~n")
  (fprintf out "  public func write(to out: OutputPort) {~n")
  (for ([f (in-list fields)])
    (define camel-id (~name (record-field-id f)))
    (fprintf out "    ~a.write(to: out)~n" camel-id))
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(module+ main
  (require racket/cmdline)
  (command-line
   #:args [modpath]
   (parameterize ([current-output-port (current-error-port)])
     (dynamic-require modpath #f)))
  (write-Swift-code))
