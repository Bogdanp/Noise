#lang racket/base

(require racket/format
         racket/match
         "private/serde.rkt")

(provide
 write-Swift-code)

(define (swift-type t)
  ((field-type-swift-proc t)))

(define (~hex n)
  (~a "0x" (number->string n 16)))

(define (~case id)
  (define s (symbol->string id))
  (begin0 s
    (string-set! s 0 (char-downcase (string-ref s 0)))))

(define (indirect? r)
  (ormap (Î» (f) (eq? Record (record-field-type f)))
         (record-info-fields r)))

(define (write-Swift-code [out (current-output-port)])
  (fprintf out "// This file was automatically generated by noise-serde-lib.~n")
  (fprintf out "import Foundation~n")
  (fprintf out "import NoiseSerde~n~n")

  (fprintf out "public enum Record: Readable, Writable {~n")
  (define sorted-ids (sort (hash-keys record-infos) <))
  (for ([id (in-list sorted-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (define maybe-indirect
      (if (indirect? r)
          " indirect"
          ""))
    (fprintf out " ~a case ~a(~a)~n" maybe-indirect (~case name) name))

  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> Record? {~n")
  (fprintf out "    guard let id = UVarint.read(from: inp, using: &buf) else {~n")
  (fprintf out "      return nil~n")
  (fprintf out "    }~n")
  (fprintf out "    switch id {~n")
  (for ([id (in-list sorted-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (fprintf out "    case ~a:~n" (~hex id))
    (fprintf out "      return .~a(~a.read(from: inp, using: &buf)!)~n" (~case name) name))
  (fprintf out "    default:~n")
  (fprintf out "      return nil~n")
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    switch self {~n")
  (for ([id (in-list sorted-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (fprintf out "    case .~a(let r): r.write(to: out)~n" (~case name)))
  (fprintf out "    }~n")
  (fprintf out "  }~n")
  (fprintf out "}~n")

  (for ([id (in-list sorted-ids)])
    (define r (hash-ref record-infos id))
    (write-record-code r out)))

(define (write-record-code r [out (current-output-port)])
  (match-define (record-info id name _constructor fields) r)
  (fprintf out "public struct ~a: Readable, Writable {~n" name)
  (for ([f (in-list fields)])
    (fprintf out
             "  public let ~a: ~a~n"
             (record-field-id f)
             (swift-type (record-field-type f))))

  (fprintf out "  public init(~n")
  (define len (length fields))
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "    ~a: ~a~a~n" id type maybe-comma))
  (fprintf out "  ) {~n")
  (for ([f (in-list fields)])
    (define id (record-field-id f))
    (fprintf out "    self.~a = ~a~n" id id))
  (fprintf out "  }~n")

  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a? {~n" name)
  (fprintf out "    return ~a(~n" name)
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ", "))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "      ~a: ~a.read(from: inp, using: &buf)!~a~n" id type maybe-comma))
  (fprintf out "    )~n")
  (fprintf out "  }~n")

  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    UVarint(~a).write(to: out)~n" (~hex id))
  (for ([f (in-list fields)])
    (fprintf out "    ~a.write(to: out)~n" (record-field-id f)))
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(module+ main
  (require racket/cmdline)
  (command-line
   #:args [modpath]
   (dynamic-require modpath #f))
  (write-Swift-code))
