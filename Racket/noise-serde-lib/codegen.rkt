#lang racket/base

(require racket/format
         racket/match
         racket/string
         "private/backend.rkt"
         "private/serde.rkt")

(provide
 write-Swift-code)

(define (swift-type t)
  ((field-type-swift-proc t)))

(define (~hex n)
  (~a "0x" (number->string n 16)))

(define (~case id)
  (define s (symbol->string id))
  (begin0 s
    (string-set! s 0 (char-downcase (string-ref s 0)))))

(define (~camel-case id)
  (regexp-replace* #rx"-([a-z])"
                   (symbol->string id)
                   (lambda (_ start)
                     (string-upcase start))))

(define (indirect? r)
  (ormap (Î» (f) (eq? Record (record-field-type f)))
         (record-info-fields r)))

(define (write-Swift-code [out (current-output-port)])
  (fprintf out "// This file was automatically generated by noise-serde-lib.~n")
  (fprintf out "import Foundation~n")
  (fprintf out "import NoiseBackend~n")
  (fprintf out "import NoiseSerde~n~n")

  (fprintf out "public enum Record: Readable, Writable {~n")
  (define sorted-record-ids (sort (hash-keys record-infos) <))
  (for ([id (in-list sorted-record-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (define maybe-indirect
      (if (indirect? r)
          " indirect"
          ""))
    (fprintf out " ~a case ~a(~a)~n" maybe-indirect (~case name) name))

  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> Record? {~n")
  (fprintf out "    guard let id = UVarint.read(from: inp, using: &buf) else {~n")
  (fprintf out "      return nil~n")
  (fprintf out "    }~n")
  (fprintf out "    switch id {~n")
  (for ([id (in-list sorted-record-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (fprintf out "    case ~a:~n" (~hex id))
    (fprintf out "      return .~a(~a.read(from: inp, using: &buf)!)~n" (~case name) name))
  (fprintf out "    default:~n")
  (fprintf out "      return nil~n")
  (fprintf out "    }~n")
  (fprintf out "  }~n")

  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    switch self {~n")
  (for ([id (in-list sorted-record-ids)])
    (define r (hash-ref record-infos id))
    (define name (record-info-name r))
    (fprintf out "    case .~a(let r): r.write(to: out)~n" (~case name)))
  (fprintf out "    }~n")
  (fprintf out "  }~n")
  (fprintf out "}~n")

  (for ([id (in-list sorted-record-ids)])
    (define r (hash-ref record-infos id))
    (write-record-code r out))

  (fprintf out "public class Backend {~n")
  (fprintf out "  let impl: NoiseBackend.Backend!~n")
  (fprintf out "  init(withZo zo: URL, andMod mod: String, andProc proc: String) {~n")
  (fprintf out "    impl = NoiseBackend.Backend(withZo: zo, andMod: mod, andProc: proc)~n")
  (fprintf out "  }~n")
  (define sorted-rpc-ids (sort (hash-keys rpc-infos) <))
  (for ([id (in-list sorted-rpc-ids)])
    (match-define (rpc-info _ name args type _proc)
      (hash-ref rpc-infos id))
    (define args-str
      (string-join
       (for/list ([arg (in-list args)])
         (match-define (rpc-arg label name type) arg)
         (format "~a ~a: ~a"
                 (~camel-case label)
                 (~camel-case name)
                 (swift-type type)))
       ", "))
    (fprintf out "  public func ~a(~a) -> Future<~a> {~n" (~camel-case name) args-str (swift-type type))
    (fprintf out "    return impl.send(~n")
    (fprintf out "      writeProc: { (out: OutputPort) in~n")
    (fprintf out "        UVarint(~a).write(to: out)~n" (~hex id))
    (for ([arg (in-list args)])
      (match-define (rpc-arg _label name _type) arg)
      (fprintf out "        ~a.write(to: out)~n" (~camel-case name)))
    (fprintf out "      },~n")
    (fprintf out "      readProc: { (inp: InputPort, buf: inout Data) -> ~a in~n" (swift-type type))
    (fprintf out "        return ~a.read(from: inp, using: &buf)!~n" (swift-type type))
    (fprintf out "      }~n")
    (fprintf out "    )~n")
    (fprintf out "  }~n"))
  (fprintf out "}~n"))

(define (write-record-code r [out (current-output-port)])
  (match-define (record-info id name _constructor fields) r)
  (fprintf out "public struct ~a: Readable, Writable {~n" name)
  (for ([f (in-list fields)])
    (fprintf out
             "  public let ~a: ~a~n"
             (record-field-id f)
             (swift-type (record-field-type f))))

  (fprintf out "  public init(~n")
  (define len (length fields))
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "    ~a: ~a~a~n" id type maybe-comma))
  (fprintf out "  ) {~n")
  (for ([f (in-list fields)])
    (define id (record-field-id f))
    (fprintf out "    self.~a = ~a~n" id id))
  (fprintf out "  }~n")

  (fprintf out "  public static func read(from inp: InputPort, using buf: inout Data) -> ~a? {~n" name)
  (fprintf out "    return ~a(~n" name)
  (for ([(f idx) (in-indexed (in-list fields))])
    (define last? (= idx (sub1 len)))
    (define maybe-comma (if last? "" ","))
    (define id (record-field-id f))
    (define type (swift-type (record-field-type f)))
    (fprintf out "      ~a: ~a.read(from: inp, using: &buf)!~a~n" id type maybe-comma))
  (fprintf out "    )~n")
  (fprintf out "  }~n")

  (fprintf out "  public func write(to out: OutputPort) {~n")
  (fprintf out "    UVarint(~a).write(to: out)~n" (~hex id))
  (for ([f (in-list fields)])
    (fprintf out "    ~a.write(to: out)~n" (record-field-id f)))
  (fprintf out "  }~n")

  (fprintf out "}~n"))

(module+ main
  (require racket/cmdline)
  (command-line
   #:args [modpath]
   (parameterize ([current-output-port (current-error-port)])
     (dynamic-require modpath #f)))
  (write-Swift-code))
